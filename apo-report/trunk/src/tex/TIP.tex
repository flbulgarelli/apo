\section{Aplicación de ejemplo}
(Fijarse si se puede poner en la problemática)
1)Edición con cancelar
2)múltiple cancelaciones
3)buscador
4)monitor de transacciones


\section{Nuestra herramienta: }
{\bf Aspect for Pure Object } \emph{APO} es una abstracción del framework
Javassist, que nos permite fácilmente implementar un aspecto, y aplicarlo a un grupo de
objetos.

\bigskip 

Se evaluaron dos frameworks para resolver nuestro problema. Uno es Javassist y
el otro AspectJ. \cite{KiczalesHHKPG01}

\bigskip

Se utiliza Javassist porque es independiente al usuario, en cambio si utilizamos
AspectJ obligamos al consumidor a cambiar la implementación de sus objetos,
y cambiar el compilador del código. 

\bigskip

Utilizando esta herramienta se implementaron dos aspectos diferentes:

	\subsection{Aspecto Transaccional:} Esta basado en una implementación
	hecha por Nicolás Passerini y Javier Fernandes.
	 
	{\bf Implementación}.
	Utilizando la programación orientada a aspectos, intercepta todas las lecturas
	y escrituras de los fields. Insertando código al momento de la carga de la 
	clase.
	Se remplaza el acceso al field, tanto de lectura como escritura, y se lo delega
	al ObjectTransactionManager, donde se guarda la informacion en una estructura
	[objeto, [Field, Valor]].
	
	\bigskip
	
	El contexto esta asociado a un solo tread, implementado con varíales del tipo
	ThreadLocal. Esto me permite manajar la concurrencia en el acceso a la
	información de los objetos. Soporta transacciones anidadas, donde cada
	transacción hija hereda el estado de su padre, y al momento de hacer un commit
	en la sub-transacción, su cambios son impactados en la transacción padre.
	Por esta forma de implementación, la identidad del objeto se mantiene, ya que
	el objeto no se modifica ni se clona, solo se cambia el acceso a sus fields.\\

	\subsection{ Aspecto Observable}
			
	{\bf Implementación.}
	En su implementación interna lo que hace el aspecto es agregar un field del
	tipo \emph{PropertyChangeSupport} al objeto que se va a convertir en
	Observable. Y a su vez le agrega métodos para completar su objetivo.
	El primero es el \emph{firePropertyChange} que es el que notifica a los
	Observadores que una propiedad ha cambiado.	Luego le agregamos
	\emph{addPropertyChangeListener} y \emph{removePropertyChangeListener} para
	poder agregar y remover Observadores para que escuchen sus cambios.


\subsection{Integración con el dominio } 
	La integración con el dominio es fácil, se puede configurar con
	anotaciones, y el Framework me permite poder tener uno u otro aspecto, o
	ambos.
	
	
\subsection{Integración de aspectos con el Arena}
En Arena se integró los dos aspectos, el Observable y el transaccional, con el
fin de que los objetos de dominio sean puros, y que no tengan la noción de
eventos, ni transacciones, y así poder bindearlos con los componentes del arena,
y al cancelar la edición poder revertir los cambios transparéntenme.
Para ello se tubo que asociar una transacción con una ventana, en el caso mas
especifico con la clase TransactionalDialog. A su vez también tenemos vinculado
los eventos del dominio junto con la ventana y la transacción, con el objetivo
de que la ventana solo escuche los eventos que ocurren en su transacción.
(Ver como redactar mejor esto\ldots )

	
\subsection{Buscar un  titulo}
La implementación de la integración en el arena se realizó con Scala, agregando
mejora al Arena como: \ldots \ldots \ldots. 
	
	
(poder hacer otra implementación de (eventos | Swing) y utilizarlo con las
transacciones (trabajo futuro si no se llega))

Contar que esta publicado, con la licencia y blah

Test de los aspectos


